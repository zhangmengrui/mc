def pi(x, y, N):
    
    """
   Fit the model according to the given training data.

   Parameters
   ----------
   x : x is a numerical value produced by a uniform random sampling in the range of -1 to +1, 
      and it is combined with the group of y values obtained by random sampling in the same range to form a random point.

   y : y is a value generated by uniform random sampling in the range of -1 to +1, 
      and it is combined with the group of x-values obtained by random sampling in the same range to form a random point.
      
   N : number of experiments.

   Returns
   -------
   frequency and estimated PI.

   Notes
   -----
    """
    
    ### In this experiment, random sampling was uniformly randomized from the range of -1 ~ +1, yielding x and y. Defines the function is_inside_unit_circle determines whether the point (x,y) falls inside the identity circle.    
    
    def is_inside_unit_circle(x, y):
        ### BEGIN SOLUTION 
        return x**2 + y**2 < 1
        ### END SOLUTION 
    assert is_inside_unit_circle(0.5,-0.5) == True
    assert is_inside_unit_circle(0.999,0.2) == False
    assert is_inside_unit_circle(0,0) == True
    ### BEGIN HIDDEN TESTS
    assert is_inside_unit_circle(0.5,-0.5) == True
    assert is_inside_unit_circle(-0.9,0.9) == False
    ### END HIDDEN TESTS

    # Monte-Carlo: PI
    import numpy as np
    N = 1000000
    xs = np.random.uniform(-1,1,N)
    ys = np.random.uniform(-1,1,N)
    # cnt 用来统计落在圆内点的数目
    cnt = 0
    for i in range(N):
        if (is_inside_unit_circle(xs[i], ys[i])):
            cnt += 1    
    print(4.0 * cnt / N) 

    # Implementation 2: Monte-Carlo: PI
    import numpy as np
    N  = 1000000
    pts = np.random.uniform(-1,1,(N,2))
    # Select the points according to your condition
    idx = (pts**2).sum(axis=1)  <= 1.0
    frequency = idx.sum()/N
    PI = idx.sum()/N*4
    print("frequency = {}/{} = {}".format(idx.sum(), N, idx.sum()/N))
    print("PI = {}".format(idx.sum()/N*4))
    
    return frequency, PI
          

 
  
    
    
def parcel(N, num_players, num_ops):
    
    """
   Fit the model according to the given training data.

   Parameters
   ----------
   N : number of experiments.

   num_players : the number of players.
      
   num_ops : the number of passes per experiment.

   Returns
   -------
   P

   Notes
   -----
   """
    
    ### A, B, C, D, E five people in a circle to play the game of passing, the rule is that each person can only pass to the neighbor (to the left or to the right).Start the game with A.Q: After 10 passes, what is the probability that the ball will return to A's hand?Use the Monte Carlo method for calculations and compare them with classical probability calculations.
    
    # 将用到以下函数
    import random
    random.choice([-1, +1]) # 随机产生-1或+1的函数，用于表示球左传(-1)或右传(+1)

    def rollingGame(N, num_players, num_ops):
        '''模拟实验函数。
        [球回到A手中的实验次数，球回到A手中的实验编号数组] = RollingGame(实验次数, 玩家数目，每次实验传球次数)
        '''
        L=0
        history = []
        for iter in range(N):
            position = 0
            for op in range(num_ops):
                position = (position + random.choice([-1, +1]) + num_players) % num_players # %表示mod运算
            history.append(position)
            if(position == 0):
                L += 1
        return L/N, history

    # 调用模拟实验函数,模拟10万次。
    num_players = 10
    num_ops = 10
    N = 100000
    P, history = rollingGame(N, num_players, num_ops)
    print('仿真结果:', P)

    return P





def dices(N):
    """
   Fit the model according to the given training data.

   Parameters
   ----------
   N : number of experiments.

   Returns
   -------
   The probability of each case and verifies whether it satisfies the normalization.

   Notes
   -----
   When calculating the probability that the three dice have different points, it is necessary to remove the cases where the number of points is 1, 2, 3, and 4, 5, and 6, respectively.
    """

    ### Randomly roll three dice and calculate the probabilities of various situations. The corresponding score for each dice point is as follows: if the three dice have 1, 2, 3 points or 4, 5 and 6 respectively, 16 points are awarded; If all three dice have the same number of points, 8 points are awarded; If only two of the dice have the same number of points, 2 points are awarded; If the three dice have different points, 0 points are awarded.

    import numpy as np
    from tqdm import tqdm

    N = 10000000
    samples = np.random.randint(low=1, high=7, size=(N,3)) # range: [low, high)
    dict_cnt = {}
    dict_cnt['ooo'] = 0 # 三个相同
    dict_cnt['123'] = 0
    dict_cnt['456'] = 0
    dict_cnt['xyz'] = 0 # 三个均不同，但需排除123和456的情况
    dict_cnt['oox'] = 0 # 两个相同

    for s in tqdm(samples):
        if s[0] == s[1] and s[0] == s[2]:
            dict_cnt['ooo'] += 1
        elif sorted(s) == [1,2,3]:
            dict_cnt['123'] += 1
        elif sorted(s) == [4,5,6]:
            dict_cnt['456'] += 1
        elif s[0] != s[1] and s[0] != s[2] and s[1] != s[2]:
            dict_cnt['xyz'] += 1
        else:
            dict_cnt['oox'] += 1
    print(dict_cnt)

    # Theoretical value:
    dict_cnt = {}
    dict_cnt['ooo'] = 6*(1/6)**3
    dict_cnt['123'] = 6*(1/6)**3
    dict_cnt['456'] = 6*(1/6)**3
    dict_cnt['xyz'] = 6*5*4/(6**3)-dict_cnt['123']-dict_cnt['456']
    dict_cnt['oox'] = 6*5*3/(6**3)
    print(dict_cnt)    

    print(dict_cnt['ooo'] + dict_cnt['xyz'] + dict_cnt['123'] + dict_cnt['456'] + dict_cnt['oox'])# 满足归一化

    # Calculate theoretical values using scipy multinomial, consistent with a polynomial distribution:
    from scipy.stats import multinomial
    rv = multinomial(3, [1/6]*6)
    rv.pmf([1, 1, 1, 0, 0, 0]) # 123 或 456 的情况

    return 



def galton_board():
    
    return binom(num_rounds, n, display = True) 





def paper_clips():
    
    return zipf(num_rounds, num_clips, display = True)

